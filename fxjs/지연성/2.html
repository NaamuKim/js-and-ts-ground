<script src="../shop/lib/fx.js"></script>

<h2>제너레이터/이터레이터 프로토콜로 구현하는 지연</h2>
<ul>
  <li>제때 계산법</li>
  <li>느긋한 계산법</li>
</ul>
<h3>L.map</h3>
<p>평가를 미루는 성질을 가진 제너레이터 함수</p>
<script>
  const L = {};
  L.map = function* (f, iter) {
    for (const a of iter) yield f(a);
  };
  var it = L.map((a) => a + 10, [1, 2, 3]);
  log([...it]);
</script>
<h3>L.filter</h3>
<script>
  L.filter = function* (f, iter) {
    for (const a of iter) if (f(a)) yield a;
  };
  var it = L.filter((a) => a % 2, [1, 2, 3, 4]);
</script>
<h3>range, map, filter, take, reduce 중첩 사용</h3>
<script>
  const take = curry((l, iter) => {
    const res = [];
    for (const a of iter) {
      res.push(a);
      if (res.length === l) return res;
    }
    return res;
  });
  const add = (a, b) => a + b;
  const range = (l) => {
    let i = -1;
    const res = [];
    while (++i < l) {
      res.push(i);
    }
    return res;
  };
  L.range = function* (l) {
    let i = -1;
    const res = [];
    while (++i < l) {
      res.push(i);
    }
    return res;
  };
  go(
    range(10),
    map((n) => n + 10),
    filter((n) => n % 2),
    take(2),
    log
  );
</script>
<h3>L.range, L.map, L.filter, take, reduce 중첩 사용</h3>
<script>
  go(
    L.range(10),
    L.map((n) => n + 10),
    L.filter((n) => n % 2),
    take(2),
    log
  );
</script>
