### 주제: JWT방식의 인증

---

### 메모

### 해결한 문제

- 세션에 정보를 저장하면 서버 자체에 저장해놓는 것이기 때문에 인증 서버가 여러 대여도 해당 세션이 있는 곳에 요청을 보내야한다.

### 무엇인가?

사용자의 연결가능한 상태의 저장을 클라이언트 측에 두 개의 토큰을 만들어 넘기는 것

###### 1. accessToken

accessToken을 복호화해서 사용자 정보를 가져온다.
accessToken을 탈취하고 요청을 보내면 인증이 필요한 정보를 가져올 수 있다.
-> 보안을 위해
XSS를 막기 위해서 할 수 있는 방법
accessToken 탈취를 막기 위해 브라우저에서 접근이 안 되게 해야함

- HTTP 헤더에 넣고 브라우저에서 접근 가능한 그 어떤 곳에도 놓지 않는다.
- 특히 로컬스토리지같은 window에서 접근이 가능한 곳에서 놓으면 안됨
  CSRF를 막기 위해서 할 수 있는 방법
- HTTP 헤더에 넣으면 url만으로는 헤더에서 토큰을 따오기 쉽지 않다.
- get요청으로 조작할 수 있는 api들을 최소화한다.
  하지만 늘 어떻게든 털릴 수 있는 것을 가정한다.
  -> 만료시간을 최대한 짧게 만들어놓을 것
  -> 한번 더 암호화하는 것도 고려할 수 있음

###### 2. refreshToken

해당 refrehToken이 서버에서 발급한 게 맞다면 새로운 accessToken을 발급받을 수 있다.
-> 보안을 위해
XSS를 막기 위해서 할 수 있는 방법

- window객체에서 접근이 가능한 곳에 넣으면 안된다.
- 서버에서 HTTP Only 옵션 쿠키에 넣어서 줘서 클라이언트에서는 조작하지 않게 하는 게 좋다.

### 프론트엔드에서의 사용

###### 보안이 좋은 상황이라면 인증 이후에 딱히 해줄 게 없어야한다.

브라우저에서 접근을 어렵게 만들어야하기 때문에 JS로 조작하는 부분도 최소화해야한다.
그러면 쿠키에 refreshToken을 넣게 되는데 그러면 accessToken이 만료돼있을 시 req.cookie를 확인해보면 되기 때문이다.

### 출처(참고문헌)

- [자동갱신](https://slog.website/post/10)
- [프론트에서 csrf 방어](https://velog.io/@jmyoon8/CSRF%EA%B3%B5%EA%B2%A9%EB%B0%A9%EC%96%B4%ED%95%98%EA%B8%B0ft.-%EB%A1%9C%EA%B7%B8%EC%9D%B8-%EB%B0%A9%EB%B2%95#%EC%9D%BC%EB%8B%A8-csrf-%EA%B0%80-%EB%AD%94%EC%A7%80-%EC%95%8C%EC%95%84%EC%95%BC-%EB%B0%A9%EC%96%B4%EB%A5%BC-%ED%95%A0%EC%88%98%EC%9E%88%EA%B2%A0%EB%8B%A4)

### 연결문서

- [[Cookie Session]]
